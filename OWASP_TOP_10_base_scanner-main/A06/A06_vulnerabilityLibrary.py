from A06.DependencyfilesParser import DependencyfilesParser 
import logging
import requests
import json
import os as _os

from dataclasses import dataclass, asdict
from typing import Optional, List
from dataclasses import field

@dataclass
class Vulnerability:
    # vuln_id: str                      # 취약점 고유 식별 자 (예: "GHSA-xxxx-xxxx-xxxx")
    # package: str                      # 패키지 이름 (예: "jinja2", "sebastian/version")
    # ecosystem: str
    # aliases: Optional[list]              # "PyPI", "Packagist", "crates.io", "Go", "Maven", "RubyGems"
    # versions: list              # 내가 검사한 버전
    # is_vulnerable: bool               # 해당 버전이 영향 받는지 최종 판정

    # summary: Optional[str] = None     # 짧은 설명(있으면 보기 편함)
    # details: Optional[str] = None   # 상세 설명(있으면 보기 편함)
    # severity: Optional[str] = None    # 정규화된 심각도(LOW/MEDIUM/HIGH/CRITICAL 등)
    # references: List[str] = field(default_factory=list)  # URL들만 평면 리스트

    # NEW
    id : Optional[str] = None          # 취약점 고유 식별 자 (예: "GHSA-xxxx-xxxx-xxxx")
    details : Optional[str] = None   # 상세 설명(있으면 보기 편함)
    package : Optional[str] = None      # 패키지 이름 (예: "jinja2", "sebastian/version")
    ecosystem : Optional[str] = None   # "PyPI", "Packagist", "crates.io", "Go", "Maven", "RubyGems"  
    ranges : Optional[list] = None     # 영향 받는 버전 범위
    versions : Optional[list] = None   # 내가 검사한 버전 
    # references : Optional[list] = None # URL들

    def to_dict(self):
        """Vulnerability 객체를 딕셔너리로 변환"""
        return asdict(self)
    
    def to_json(self):
        """Vulnerability 객체를 JSON 문자열로 변환"""
        return json.dumps(asdict(self), indent=2, ensure_ascii=False)

_log_dir = _os.path.join(_os.path.dirname(_os.path.dirname(_os.path.abspath(__file__))), "logs")
_os.makedirs(_log_dir, exist_ok=True)

logging.basicConfig(
    filename=_os.path.join(_log_dir, "A06_vulnerability_Library.log"),
    filemode='a',
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)   

class vulnerabilityLibrary:

    OSV_API = "https://api.osv.dev/v1/query"
    

    def __init__(self):
        self.packages= list()
        self.vulnerabilities = list()

    def parse_scan_result(self, results):
        """스캔 결과를 파싱하여 테스트 항목 생성 (중복 제거 포함)"""
        logging.info("vulnerabilityLibrary - Parsing scan results...")
        details = []
        seen_vulnerabilities = set()  # (id, package) 조합으로 중복 체크

        try:
            for result in results:
                vuln_id = getattr(result, "id", "UNKNOWN")
                package = getattr(result, "package", "UNKNOWN")

                # (id, package) 조합으로 중복 체크
                vuln_key = (vuln_id, package)

                if vuln_key not in seen_vulnerabilities:
                    seen_vulnerabilities.add(vuln_key)
                    details.append(
                        {
                            "id": vuln_id,
                            "package": package,
                            "version": getattr(result, "versions", []),
                            "ecosystem": getattr(result, "ecosystem", "UNKNOWN"),
                            "description": f"Details: {getattr(result, 'details', 'N/A')}",
                        }
                    )

        except Exception as e:
            print(f"❌ 결과 파싱 오류: {e}")

        logging.info(f"중복 제거 완료: {len(results)}개 → {len(details)}개 고유 취약점")
        return details

    def query(self, pkg):
        """ OSV API에 보낼 쿼리 생성 """
        logging.info(f"vulnerabilityLibrary - Creating query for package: {pkg.get('package_name', 'Unknown')}")

        return {
            "package": {
                "name": pkg.get("package_name", ""),
                "ecosystem": pkg.get("ecosystem", "PyPI")  # 기본값 설정
            },
            "version": pkg.get("version", "")
        }
        # return {
        #     "package": {
        #         "purl": "pkg:pypi/jinja2@3.1.4"
        #     }
        # }
    
        # return {
        #     "package": {
        #         "purl": "pkg:pypi/jinja2"
        #     },
        #     "version": "3.1.4"
        # }


    def get_package_info(self, dependencyfiles): 
        """ 의존성 파일에서 사용하는 패키지 정보 추출 """
        logging.info("vulnerabilityLibrary - Getting package info...")
        try:
            depfile_parser = DependencyfilesParser()  # 인스턴스 생성
            
            for file in dependencyfiles:
                logging.info(f"Processing {file}...")
                parsed_packages = depfile_parser.parse(file)  # 인스턴스 메서드 호출
                if parsed_packages:
                    self.packages.extend(parsed_packages)  # 리스트이므로 extend 사용
        except Exception as e:
            logging.error(f"vulnerabilityLibrary - Error parsing dependency files: {e}")

    def request_vulnerabilities(self, pkg):
        """ OSV API에 패키지 정보로 취약점 정보 요청 """
        logging.info(f"vulnerabilityLibrary - Requesting vulnerabilities for package: {pkg.get('package_name', 'Unknown')}")
        query_list = []
        # result = []

        try:
            query = self.query(pkg)
            query_list.append(query)
        
            for query in query_list:
                logging.info(f"Querying OSV API with: {query}")

                response = requests.post(self.OSV_API, json=query)
                if response.status_code == 200:
                    logging.info(f"request_vuln() Vulnerabilities found: {len(response.json().get('vulns', []))}")

                    with open("osv_response.json", "a", encoding="utf-8") as f:
                        json.dump(response.json(), f, ensure_ascii=False, indent=2)
                    self.vulnerabilities.extend(response.json().get("vulns", []))
                else:
                    logging.error(f"vulnerabilityLibrary - Error querying OSV API: {response.status_code}, {response.text}")
        except Exception as e:
            logging.error(f"vulnerabilityLibrary - Error requesting vulnerabilities: {e}")

    def parse_vulnerabilities(self):
        """ 취약점 정보 파싱 """
        logging.info("vulnerabilityLibrary - Parsing vulnerabilities...")
        logging.info(f"vulnerabilityLibrary - Total vulnerabilities found: {len(self.vulnerabilities)}")
        
        if not self.vulnerabilities:
            logging.info("vulnerabilityLibrary - No vulnerabilities to parse.")
            return []

        parsed_vulnerabilities = []

        try:
            for vuln in self.vulnerabilities:
                logging.info(f"Vulnerability ID: {vuln}")
                affected = vuln.get("affected", [{}])[0]          # 취약점 정보를 Vulnerability 객체로 변환
                
                # vulnerability_obj = Vulnerability(
                #     vuln_id=vuln.get("id", "Unknown"), 
                #     package=affected.get("package", {}).get("name", "Unknown"),
                #     ecosystem=affected.get("package", {}).get("ecosystem", "Unknown"),
                #     aliases=affected.get("package", {}).get("aliases", []),
                #     versions=affected.get("versions", "Unknown"),  # 이 정보는 별도로 추적해야 합니다
                #     is_vulnerable=True,  # OSV API에서 반환된 것이므로 취약점이 있는 것으로 간주

                #     summary=vuln.get("summary", "Unknown"),
                #     details=vuln.get("details", "Unknown"),
                #     severity=vuln.get("database_specific", {}).get("severity", "Unknown") if vuln.get("database_specific") else "Unknown",
                #     references=[ref.get("url") for ref in vuln.get("references", []) if ref.get("url")]
                # )

                vulnerability_obj = Vulnerability(
                    id=vuln.get("id", "Unknown"),
                    details=vuln.get("details", "Unknown"),
                    package=affected.get("package", {}).get("name", "Unknown"),
                    ecosystem=affected.get("package", {}).get("ecosystem", "Unknown"),
                    ranges=affected.get("ranges", []),
                    versions=affected.get("versions", []),  # 이 정보는 별도로 추적해야 합니
                )

                logging.info(f"vulnerabilityLibrary - Parsed Vulnerability: {vulnerability_obj}")

                parsed_vulnerabilities.append(vulnerability_obj)

        except Exception as e:
            logging.error(f"vulnerabilityLibrary - Error parsing vulnerabilities: {e}")

        return parsed_vulnerabilities

    def run(self, dependencyfiles):
        """ 전체 프로세스 실행 """
        logging.info("vulnerabilityLibrary - Running vulnerability scan...")
        try:
            # 의존성 파일 유무 확인
            if not dependencyfiles:
                logging.warning("vulnerabilityLibrary - No dependency files found.")
                return []

            self.get_package_info(dependencyfiles)
            logging.info(f"vulnerabilityLibrary - Total packages found: {len(self.packages)}")

            for pkg in self.packages:
                if pkg.get("package_name"):  # 패키지 이름이 있는 경우만 처리
                    self.request_vulnerabilities(pkg)

            vulnerabilities = self.parse_vulnerabilities()
            
            print(f"Total vulnerabilities found: {len(vulnerabilities)}")
            details = self.parse_scan_result(vulnerabilities)
            print(f"Total details parsed: {len(details)}")
            

            # JSON 형식으로 변환하여 반환
            # json_vulnerabilities = []
            # for vuln in vulnerabilities:
            #     json_vulnerabilities.append(vuln.to_dict())
                
            # return json_vulnerabilities
            
        except Exception as e:
            logging.error(f"vulnerabilityLibrary - Error during run process: {e}")
            return []

        return details


    #Test 용
    def save_vulnerabilities_to_json_file(self, dependencyfiles, filename="vulnerabilities.json"):
        """ 취약점 정보를 JSON 파일로 저장 """
        vulnerabilities = self.run(dependencyfiles)

        with open(filename, "w", encoding="utf-8") as f:
            json.dump(vulnerabilities, f, indent=2, ensure_ascii=False)

        logging.info(f"vulnerabilityLibrary - Vulnerabilities saved to {filename}")
        return filename

    def __repr__(self):
        return f"Vulnerability(name={self.name}, severity={self.severity})"
    


def test():

    query = {'package': {'name': 'sebastian/version', 'ecosystem': 'Packagist'}, 'version': '2.0.1'}
    query = 	{ "package": { "name": "jinja2", "ecosystem": "PyPI" }, "version": "3.1.4" }


    response = requests.post("https://api.osv.dev/v1/query", json=query)
    with open("jtest.json", "w") as f:
        json.dump(response.json(), f, indent=2)




if __name__ == "__main__":
    # test()
    # exit(0)
    sample =[
  {
    "type": "package.json",
    "content": "{\n  \"name\": \"sample-project\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"node index.js\",\n    \"build\": \"tsc\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.2\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^5.2.2\",\n    \"jest\": \"^29.6.2\"\n  }\n}"
  },
  {
    "type": "tsconfig.json",
    "content": "{\n  \"extends\": \"@tsconfig/node16/tsconfig.json\",\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"CommonJS\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"ES2020\", \"DOM\"],\n    \"typeRoots\": [\"./node_modules/@types\"],\n    \"paths\": {\n      \"@/*\": [\"./src/*\"],\n      \"@types/*\": [\"./node_modules/@types/*\"]\n    }\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\"]\n}"
  },
  {
    "type": "requirements.txt",
    "content": "flask==2.3.2\nrequests==2.31.0\nnumpy==1.25.0\npandas==2.0.2"
  },
  {
    "type": "Pipfile",
    "content": "[[source]]\nname = \"pypi\"\nurl = \"https://pypi.org/simple\"\nverify_ssl = true\n\n[packages]\nflask = \"==2.3.2\"\nrequests = \"*\"\n\n[dev-packages]\npytest = \"*\"\n\n[requires]\npython_version = \"3.11\""
  },
  {
    "type": "pyproject.toml",
    "content": "[build-system]\nrequires = [\"setuptools>=61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"sample-python-project\"\nversion = \"0.1.0\"\ndependencies = [\n    \"requests>=2.31\",\n    \"flask>=2.3\"\n]"
  },
  {
    "type": "setup.py",
    "content": "from setuptools import setup, find_packages\n\nsetup(\n    name=\"sample-python-project\",\n    version=\"0.1.0\",\n    packages=find_packages(),\n    install_requires=[\n        \"flask>=2.3.2\",\n        \"requests>=2.31.0\"\n    ]\n)"
  },
  {
    "type": "Cargo.toml",
    "content": "[package]\nname = \"sample-rust-project\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ntokio = { version = \"1.28\", features = [\"full\"] }\nreqwest = \"0.11\""
  },
  {
    "type": "Cargo.lock",
    "content": "[[package]]\nname = \"tokio\"\nversion = \"1.28.0\"\n\n[[package]]\nname = \"reqwest\"\nversion = \"0.11.18\""
  },
  {
    "type": "go.mod",
    "content": "module github.com/example/sample-go-project\n\ngo 1.20\n\nrequire (\n    github.com/gin-gonic/gin v1.9.0\n    github.com/stretchr/testify v1.8.4\n)"
  },
  {
    "type": "go.sum",
    "content": "github.com/gin-gonic/gin v1.9.0 h1:...\ngithub.com/stretchr/testify v1.8.4 h1:..."
  },
  {
    "type": "pom.xml",
    "content": "<project xmlns=\"http://maven.apache.org/POM/4.0.0\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>com.example</groupId>\n  <artifactId>sample-app</artifactId>\n  <version>1.0.0</version>\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n      <version>3.1.1</version>\n    </dependency>\n  </dependencies>\n</project>"
  },
  {
    "type": "build.gradle",
    "content": "plugins {\n    id 'java'\n    id 'org.springframework.boot' version '3.1.1'\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-web:3.1.1'\n    testImplementation 'org.junit.jupiter:junit-jupiter:5.9.3'\n}"
  },
  {
    "type": "composer.json",
    "content": "{\n  \"name\": \"example/sample-php-project\",\n  \"require\": {\n    \"monolog/monolog\": \"^2.9\"\n  },\n  \"require-dev\": {\n    \"phpunit/phpunit\": \"^10.2\"\n  }\n}"
  },
  {
    "type": "composer.lock",
    "content": "{\n  \"packages\": [\n    {\n      \"name\": \"monolog/monolog\",\n      \"version\": \"2.9.1\"\n    }\n  ]\n}"
  },
  {
    "type": "Gemfile",
    "content": "source \"https://rubygems.org\"\n\ngem \"rails\", \"~> 7.0\"\ngem \"pg\", \">= 1.1\"\ngem \"puma\", \"~> 6.0\""
  },
  {
    "type": "Gemfile.lock",
    "content": "GEM\n  remote: https://rubygems.org/\n  specs:\n    rails (7.0.5)\n    pg (1.5.3)\n\nDEPENDENCIES\n  rails (~> 7.0)\n  pg (>= 1.1)"
  }
]

    with open("../add_in/data.json", "r") as f:
        data = json.load(f)

    dependencyfiles = data.get("dependnecy_files", [])
    dependencyfiles = sample  # 테스트용 샘플 데이터 사용
    
    vuln_lib = vulnerabilityLibrary()
    
    # run 함수에서 바로 JSON 형식으로 받기
    # json_vulnerabilities = vuln_lib.save_vulnerabilities_to_json_file(dependencyfiles)
    result = vuln_lib.run(dependencyfiles)

    with open("Library_vulnerabilities.json", "w", encoding="utf-8") as f:
        json.dump(result, f, indent=2, ensure_ascii=False)
    # print(json.dumps(json_vulnerabilities, indent=2, ensure_ascii=False))